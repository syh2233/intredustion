太棒了！下面给你一份**针对宿舍场景**、只用**ESP32 + 火焰传感器 + MQ-2 + 0.96 OLED + 小风扇 + Flask Web**的**极简火灾报警系统**的完整步骤与指南（含可直接使用的示例代码）。

---

# 1. 物料与连接

## 1.1 物料清单（BOM）

* ESP32 开发板（带 USB）
* 扩展板/面包板、杜邦线、排针排母
* 火焰传感器模块（模拟量输出 AO）
* MQ-2 烟雾传感器模块（模拟量输出 AO）
* 0.96" OLED（I2C，SSD1306 128×64）
* 130 小风扇（5V/3.3V，推荐配**NPN 三极管 + 二极管**或小继电器）
* 3.3 V 稳压模块（若传感器需 3.3V 供电）
* USB 线、电源

> MQ-2 预热 24–48 小时更稳定；如采用 5V 供电的 MQ-2，请**分压**或**运放**把 AO 调到 ESP32 可承受范围（0–3.3V）。

## 1.2 引脚与接线（推荐）

| 模块         | 引脚      | ESP32 引脚           | 说明              |
| ---------- | ------- | ------------------ | --------------- |
| 火焰传感器      | AO      | GPIO34 (ADC1\_CH6) | 仅输入             |
| MQ-2       | AO      | GPIO35 (ADC1\_CH7) | 仅输入；注意电平        |
| OLED (I2C) | SDA/SCL | GPIO21 / GPIO22    | 3.3V 供电         |
| 供电         | VCC/GND | 3.3V/ GND          | 传感器/ESP32 共地    |

---

# 2. 系统功能与阈值策略（宿舍极简）

* **触发条件（任一满足即报警）**

  * 火焰模拟值低于阈值（许多火焰模块输出“有火→电压低”）：`flame_raw < FLAME_THR`
  * MQ-2 模拟值高于阈值：`smoke_raw > MQ2_THR`
* **动作**

  * OLED 红色页/反白：“🔥 火灾报警”
  * 接蜂鸣器报警
  * 以 JSON 通过 HTTP POST 上传 Flask：`/api/data`
* **去抖**：同一状态持续 N 秒只报一次；恢复正常后再允许下一次触发
* **校准**：首次部署记录 1–2 天“正常环境”平均值，动态微调阈值

**起始阈值建议（需现场实测再微调）**

* `FLAME_THR = 1200`（0–4095 之间，数值越小越可能有火）
* `MQ2_THR = 1200`（0–4095 之间，数值越大烟雾越浓）

---

# 3. ESP32 端示例（Thonny）

#3. 1. 准备与刷写

1. **烧录 MicroPython 固件**

   * 到 micropython.org 下载 ESP32 固件 (`.bin`)。
   * 用 `esptool.py` 或 Thonny/MPy-Tool 烧录：

     ```bash
     esptool.py --chip esp32 --port COM5 erase_flash
     esptool.py --chip esp32 --port COM5 --baud 460800 write_flash -z 0x1000 esp32-<version>.bin
     ```
3.2. **依赖文件**（复制到开发板 / 根目录）

   * `main.py`（主程序，下面给出）
   * `secrets.py`（Wi-Fi 与服务器配置）
   * `urequests.py`（若固件不带就上传一份，常见版本可在 micropython-lib 找到）
   * `ssd1306.py`（有些固件自带；若没有，上传官方驱动）

---

# 1. 硬件连线（与前文一致）

| 模块         | 引脚      | ESP32 引脚           | 说明                   |
| ---------- | ------- | ------------------ | -------------------- |
| 火焰传感器      | AO      | GPIO34 (ADC1\_CH6) | 仅输入                  |
| MQ-2       | AO      | GPIO35 (ADC1\_CH7) | 仅输入（⚠️确保≤3.3V，必要时分压） |
| OLED (I2C) | SDA/SCL | GPIO21 / GPIO22    | 3.3V 供电，地址 0x3C      |
| 供电         | VCC/GND | 3.3V / GND         | 共地                   |

> **安全提醒**：多数 MQ-2 模块输出随供电电压变化。若用 5V 供电，AO 也会接近 5V，**必须分压到 ≤3.3V** 再接 ESP32 ADC。

---

# 2. `secrets.py`（配置）

```python
# secrets.py
WIFI_SSID = "your_wifi"
WIFI_PSK  = "your_pass"

# 你的 Flask 服务地址
SERVER_URL = "http://<你的服务器或域名>:5000/api/data"

# 设备标识
DEVICE_ID = "ESP32-001"
```

---

# 4. 现场调校与建议

1. **基线采样**：上电后 10–30 分钟在“正常宿舍环境”记录 flame/mq2 均值，按经验设：

   * `FLAME_THR` ≈ 正常 flame 基线 × 0.7（火焰越接近越小）
   * `MQ2_THR` ≈ 正常 mq2 基线 × 1.5–2.0
2. **预热**：MQ-2 需要预热，初期波动大；阈值请在预热稳定后调整。
3. **误报抑制**：若误报多，可把 `POST_COOLDOWN_MS` 提高，并在 `alert` 判定前加**连续 N 次满足**再报警（例如在循环里维护计数）。
4. **供电/保护**：风扇等感性负载务必三极管 + 续流二极管；MQ-2 若 5V 供电，一定分压 AO。
5. **掉线重连**：代码已在失败时重启；也可改成更温和的 `sta.disconnect(); sta.connect()`。

---

# 5. 与 Flask 后端对接

* Flask 端保持之前给你的 `POST /api/data` 接口即可，接收 JSON：

  ```json
  {"device_id":"ESP32-001","flame":1032,"smoke":1450,"alert":true}
  ```
* 前端页面每 1.5s 拉取 `/api/data/recent?limit=20` 展示最新状态（已给出模板）。

---

# 6. 可选增强（MicroPython 侧）

* **本地蜂鸣器**（GPIO26）报警声；
* **动态阈值**：滑动均值 + 偏移；
* **MQTT 模式**：将 `post_json` 改为 MQTT 发布，更实时；
* **低功耗**：空闲时可降低采样频率，或按键进入 light sleep。

---

如果你需要，我可以把这套文件按**可直接拷贝的项目结构**列出来（含 `urequests.py / ssd1306.py` 常用版本）并附上**阈值连续触发去抖**的变体代码。
> 若你的火焰模块“有火输出高电平”，将条件改为 `flame > FLAME_THR` 即可。

---

# 4. Flask 端最小可跑（含 API + 简单网页）

> 依赖：`Flask`, `Flask-Cors`, `sqlite3`（标准库）, `jinja2`（随 Flask）。
> 建议：Nginx 反代 + HTTPS；生产用 `gunicorn`.

**requirements.txt**

```
Flask==3.0.0
Flask-Cors==4.0.0
```

---

# 5. 联调与验证

1. **连接 Wi-Fi**：ESP32 串口监视器确认联网成功。
2. **静态环境**：记录 5–10 分钟火焰/烟雾基线值，微调 `FLAME_THR`、`MQ2_THR`。
3. **触发测试**：

   * 打火机火焰靠近传感器（注意安全）
   * 烟雾（点香/雾化烟雾）靠近 MQ-2
   * 观察：OLED 告警 + 风扇启动 + Web 端变红 + 表格新增记录
4. **误报控制**：若夜间误报多，适当提高 MQ-2 阈值、延长去抖时间（比如 3–5s 连续满足再报警）。

---

# 6. 部署与安全

* **Web 端**：Nginx 反向代理 Flask、签 TLS（Let’s Encrypt），限制外网只开放 80/443/5000（视需要）。
* **内网优先**：宿舍路由器内网部署较安全；外网访问需鉴权。
* **传感器供电**：确保 MQ-2 模块 AO 不超过 3.3V；必要时分压。
* **风扇/负载**：务必使用三极管/继电器隔离，串二极管防反灌。
* **日志与维护**：SQLite 文件每日/每周归档；超过 30 天自动清理。

---

# 7. 可选增强（保持极简前提下）

* 加入 **蜂鸣器**（GPIO26）本地声光报警
* **短信/微信机器人**：Flask 中在 `alert==true` 时调用通知接口
* **自学习阈值**：用最近一段时间的滑动均值±偏移做动态阈值
* **MQTT 备选**：后端改为订阅 MQTT，再写库（便于多设备扩展）

---