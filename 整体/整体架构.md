# ESP32 宿舍火灾报警系统整体架构

## 项目概述
一个针对宿舍场景设计的极简火灾报警系统，采用 ESP32 作为主控，配合多种传感器和Web界面实现实时监控和报警功能。

---

## 1. 硬件架构

### 1.1 物料清单 (BOM)
- **主控板**: ESP32 开发板（带 USB）
- **扩展硬件**: 扩展板/面包板、杜邦线、排针排母
- **传感器**: 
  - 火焰传感器模块（模拟量输出 AO）
  - MQ-2 烟雾传感器模块（模拟量输出 AO）
- **显示**: 0.96" OLED（I2C，SSD1306 128×64）
- **执行器**: 130 小风扇（5V/3.3V）
- **电源**: 3.3V 稳压模块、USB 线、电源

> **注意**: MQ-2 需预热 24-48 小时更稳定；若采用 5V 供电，需分压或运放调整到 ESP32 可承受范围（0-3.3V）

### 1.2 硬件连接

| 模块 | 引脚 | ESP32 引脚 | 说明 |
|------|------|------------|------|
| 火焰传感器 | AO | GPIO34 (ADC1_CH6) | 仅输入 |
| MQ-2 | AO | GPIO35 (ADC1_CH7) | 仅输入（注意电平≤3.3V） |
| OLED (I2C) | SDA/SCL | GPIO21 / GPIO22 | 3.3V 供电，地址 0x3C |
| 供电 | VCC/GND | 3.3V / GND | 共地 |

> **安全提醒**: MQ-2 模块输出随供电电压变化，5V 供电时必须分压到 ≤3.3V 再接 ESP32 ADC

---

## 2. 系统功能设计

### 2.1 触发条件（任一满足即报警）
- 火焰模拟值低于阈值：`flame_raw < FLAME_THR`
- MQ-2 模拟值高于阈值：`smoke_raw > MQ2_THR`

### 2.2 报警动作
- OLED 显示红色告警页面："🔥 火灾报警"
- 启动风扇排风
- 通过 HTTP POST 上传数据到 Flask 服务器：`/api/data`

### 2.3 防误报机制
- 去抖处理：同一状态持续 N 秒只报一次
- 恢复正常后允许下一次触发
- 首次部署记录 1-2 天"正常环境"平均值，动态微调阈值

### 2.4 阈值设置（起始建议，需现场微调）
- `FLAME_THR = 1200`（0-4095，数值越小越可能有火）
- `MQ2_THR = 1200`（0-4095，数值越大烟雾越浓）

---

## 3. 软件架构

### 3.1 ESP32 端 (MicroPython)

#### 文件结构
```
ESP32/
├── main.py              # 主程序
├── secrets.py           # Wi-Fi 与服务器配置
├── urequests.py         # HTTP 请求库
└── ssd1306.py           # OLED 驱动库
```

#### 配置文件 (secrets.py)
```python
# Wi-Fi 配置
WIFI_SSID = "your_wifi"
WIFI_PSK  = "your_pass"

# 服务器配置
SERVER_URL = "http://<服务器地址>:5000/api/data"
DEVICE_ID = "ESP32-001"
```

#### 主要功能
- 传感器数据采集（ADC 读取）
- Wi-Fi 连接管理
- 数据处理与阈值判断
- OLED 显示控制
- HTTP 数据上传
- MQTT 实时通信
- 掉线重连机制

#### MQTT客户端库 (MicroPython)
```python
# MQTT依赖库
umqtt.simple.py        # 简单MQTT客户端
umqtt.robust.py       # 健壮性MQTT客户端（带重连）
```

#### MQTT配置示例
```python
# secrets.py MQTT配置
MQTT_BROKER = "mqtt.example.com"
MQTT_PORT = 1883
MQTT_USER = "esp32_user"
MQTT_PASS = "secure_password"
MQTT_CLIENT_ID = "ESP32-001"

# 主题定义
MQTT_TOPIC_DATA = f"esp32/{MQTT_CLIENT_ID}/data/json"
MQTT_TOPIC_ALERT = f"esp32/{MQTT_CLIENT_ID}/alert/fire"
MQTT_TOPIC_STATUS = f"esp32/{MQTT_CLIENT_ID}/status/online"
```

### 3.2 服务器端 (Flask)

#### 依赖包
```
Flask==3.0.0
Flask-Cors==4.0.0
Flask-SocketIO==5.3.6
paho-mqtt==1.6.1
```

#### 主要功能
- RESTful API 接口
- MQTT 消息订阅和发布
- 数据存储（SQLite）
- 实时数据展示
- 报警状态管理
- 跨域请求支持
- WebSocket 实时推送

#### API 接口
- `POST /api/data` - 接收传感器数据
- `GET /api/data/recent?limit=20` - 获取最新数据
- `WebSocket /ws` - 实时数据推送

#### MQTT集成
```python
# Flask MQTT集成示例
from flask_mqtt import Mqtt

app = Flask(__name__)
mqtt = Mqtt(app)

# 订阅设备数据
@mqtt.on_connect()
def handle_connect(client, userdata, flags, rc):
    mqtt.subscribe('esp32/+/data/json')
    mqtt.subscribe('esp32/+/alert/#')
    mqtt.subscribe('esp32/+/status/#')

# 处理传感器数据
@mqtt.on_message()
def handle_mqtt_message(client, userdata, msg):
    topic = msg.topic.decode()
    payload = msg.payload.decode()
    
    if '/data/json' in topic:
        # 处理传感器数据
        data = json.loads(payload)
        save_to_database(data)
        broadcast_to_websocket(data)
    
    elif '/alert/' in topic:
        # 处理报警信息
        send_alert_notification(payload)
```

---

## 4. 数据流设计

### 4.1 数据采集流
```
传感器 → ADC 读取 → 数据处理 → 阈值判断 → 本地显示/报警
```

### 4.2 网络传输流

#### HTTP传输流
```
ESP32 → HTTP POST → Flask 服务器 → SQLite 存储
```

#### MQTT传输流
```
ESP32 → MQTT Publish → MQTT Broker → 规则引擎 → 数据存储
                                    ↓
                              WebSocket推送 → Web客户端实时更新
```

### 4.3 前端展示流

#### 传统轮询模式
```
Web 页面 → AJAX 请求 → Flask API → 数据展示
```

#### 实时推送模式
```
Web 页面 → WebSocket连接 → Flask-SocketIO → MQTT订阅 → 实时数据推送
```

### 4.4 双协议协同流程
```
传感器数据 → ESP32处理 ──┐
                        ├ HTTP POST → 配置查询、历史数据
                        └ MQTT Publish → 实时数据、报警信息
                                            ↓
                              MQTT Broker → 规则引擎 → 数据存储
                                                        ↓
                                  Flask服务器 ← WebSocket ← Web客户端
```

### 4.4 数据格式
```json
{
  "device_id": "ESP32-001",
  "flame": 1032,
  "smoke": 1450,
  "alert": true
}
```

---

## 5. 云平台设计

### 5.1 通信协议架构

#### HTTP + MQTT 双协议设计
系统采用HTTP和MQTT双协议架构，满足不同场景需求：

**HTTP协议**：
- 用于初始配置和数据查询
- RESTful API接口
- 请求-响应模式
- 适用于Web端数据获取

**MQTT协议**：
- 用于实时数据传输
- 发布-订阅模式
- 低功耗、低带宽
- 适用于实时报警和监控

### 5.2 MQTT架构设计

#### MQTT Broker配置
```yaml
# Mosquitto MQTT Broker配置
broker:
  host: "mqtt.example.com"
  port: 1883
  username: "esp32_user"
  password: "secure_password"
  qos: 1
  retain: true
```

#### 主题设计 (Topic Design)
```
# 设备数据上报
esp32/{device_id}/data/json          # 传感器数据JSON格式
esp32/{device_id}/data/structured     # 结构化数据
esp32/{device_id}/status/online      # 设备上线状态
esp32/{device_id}/status/offline     # 设备离线状态
esp32/{device_id}/alert/fire          # 火灾报警
esp32/{device_id}/alert/smoke         # 烟雾报警

# 服务器下发指令
server/{device_id}/cmd/reset         # 重置设备
server/{device_id}/cmd/config        # 配置更新
server/{device_id}/cmd/reboot        # 重启设备
server/{device_id}/cmd/threshold     # 阈值调整

# 系统管理主题
system/all/broadcast                 # 系统广播
system/all/heartbeat                 # 心跳检测
system/monitor/status               # 监控状态
```

#### MQTT数据格式
```json
// 传感器数据发布
{
  "device_id": "ESP32-001",
  "timestamp": "2024-01-01T12:00:00Z",
  "data": {
    "flame": 1032,
    "smoke": 1450,
    "temperature": 25.5,
    "humidity": 65.0
  },
  "status": {
    "alert": false,
    "battery": 85,
    "wifi_rssi": -65
  }
}

// 报警数据发布
{
  "device_id": "ESP32-001", 
  "alert_type": "fire",
  "severity": "high",
  "timestamp": "2024-01-01T12:00:00Z",
  "sensor_values": {
    "flame": 450,
    "smoke": 2100
  },
  "location": "宿舍A栋301"
}
```

### 5.3 云平台集成

#### 主流云平台MQTT支持
**阿里云IoT平台**：
- 产品创建：ESP32火灾报警器
- 设备认证：一机一密
- 数据流转：规则引擎数据处理
- 可视化：IoT Studio仪表盘

**华为云IoTDA**：
- 设备接入：MQTT 3.1.1协议
- 数据转发：DIS/OBS数据存储
- 告警管理：SMN短信通知
- 规则引擎：自动化联动

**腾讯云IoT Explorer**：
- 产品定义：自定义数据模板
- 设备管理：批量设备操作
- 数据分析：时序数据库TSDB
- 应用开发：低代码平台

#### 云平台部署架构
```
[ESP32设备] → MQTT → [云平台MQTT Broker] → [规则引擎] → [数据存储]
                                                ↓
[Web客户端] ← HTTP/API ← [应用服务器] ← [数据处理] ← [消息队列]
```

### 5.4 部署架构

#### 网络架构
```
[ESP32] → Wi-Fi → [路由器] → [Internet] → [云平台MQTT Broker]
                           ↓
                    [Flask 服务器] → [Web 客户端]
```

#### 部署方式
- **本地部署**: MQTT Broker + Flask 本地部署
- **混合部署**: 本地Flask + 云平台MQTT
- **云端部署**: 全部云平台部署（推荐）

#### 安全考虑
- MQTT TLS加密传输
- 设备身份认证
- 数据传输加密
- 访问权限控制
- 定期证书更新

---

## 6. 调试与优化

### 6.1 现场调校
1. **基线采样**: 上电后 10-30 分钟记录正常环境值
2. **阈值调整**: 
   - `FLAME_THR` ≈ 正常基线 × 0.7
   - `MQ2_THR` ≈ 正常基线 × 1.5-2.0
3. **预热处理**: MQ-2 需要预热稳定

### 6.2 误报抑制
- 提高 `POST_COOLDOWN_MS`
- 连续 N 次满足条件才报警
- 动态阈值调整

### 6.3 性能优化
- 降低空闲时采样频率
- MQTT 模式替代 HTTP
- 低功耗模式支持

---

## 7. 扩展功能

### 7.1 硬件扩展
- 本地蜂鸣器报警
- 温湿度传感器
- 摄像头监控
- 继电器控制

### 7.2 软件扩展
- 短信/微信通知
- 自学习阈值算法
- MQTT 协议支持
- 数据分析报表
- 用户权限管理

### 7.3 系统扩展
- 多设备管理
- 云平台集成
- 移动端 APP
- 机器学习预警

---

## 8. 维护与监控

### 8.1 日常维护
- 传感器定期校准
- 数据库清理（30 天自动清理）
- 系统日志监控

### 8.2 故障处理
- Wi-Fi 断线重连
- 传感器故障检测
- 服务器宕机恢复

### 8.3 性能监控
- 响应时间监控
- 数据完整性检查
- 报警准确率统计

---

## 9. 项目特点

### 9.1 优势
- **成本低廉**: 使用常见传感器和开发板
- **部署简单**: 最小化硬件配置
- **实时性好**: 本地处理 + 网络传输
- **扩展性强**: 模块化设计便于扩展

### 9.2 适用场景
- 学生宿舍
- 小型办公室
- 家庭环境
- 实验室

### 9.3 技术亮点
- MicroPython 嵌入式开发
- 实时数据处理
- Web 远程监控
- 多传感器融合

---

*注：本文档为基于 ESP32 的宿舍火灾报警系统的完整架构设计，包含硬件选型、软件设计、部署方案和扩展建议。*