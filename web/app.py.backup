#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ESP32 Dormitory Fire Alarm System - Flask Web Server
===================================================

Main Functions:
- MQTT message receiving and processing
- Sensor data storage
- Web interface providing
- Real-time data pushing
- Alarm management
"""

from flask import Flask, render_template, request, jsonify, send_from_directory
from flask_mqtt import Mqtt
from flask_socketio import SocketIO
from flask_sqlalchemy import SQLAlchemy
from flask_cors import CORS
import sqlite3
import json
import time
import os
from datetime import datetime, timedelta
import threading
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Flask application initialization
app = Flask(__name__)
app.config['SECRET_KEY'] = 'esp32_fire_alarm_system_2024'
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///fire_alarm.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

# MQTT configuration
app.config['MQTT_BROKER_URL'] = 'localhost'
app.config['MQTT_BROKER_PORT'] = 1883
app.config['MQTT_USERNAME'] = ''
app.config['MQTT_PASSWORD'] = ''
app.config['MQTT_KEEPALIVE'] = 60
app.config['MQTT_TLS_ENABLED'] = False

# Initialize extensions
db = SQLAlchemy(app)
mqtt = Mqtt(app)
socketio = SocketIO(app, cors_allowed_origins="*")
CORS(app)

# Database models
class SensorData(db.Model):
    """Sensor data model"""
    id = db.Column(db.Integer, primary_key=True)
    device_id = db.Column(db.String(50), nullable=False)
    flame_value = db.Column(db.Integer, nullable=False)
    smoke_value = db.Column(db.Integer, nullable=False)
    temperature = db.Column(db.Float)
    humidity = db.Column(db.Float)
    alert_status = db.Column(db.Boolean, default=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

class AlertHistory(db.Model):
    """Alert history model"""
    id = db.Column(db.Integer, primary_key=True)
    device_id = db.Column(db.String(50), nullable=False)
    alert_type = db.Column(db.String(20), nullable=False)
    severity = db.Column(db.String(10), nullable=False)
    flame_value = db.Column(db.Integer)
    smoke_value = db.Column(db.Integer)
    temperature = db.Column(db.Float)
    humidity = db.Column(db.Float)
    location = db.Column(db.String(100))
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)
    resolved = db.Column(db.Boolean, default=False)
    resolved_time = db.Column(db.DateTime)

class DeviceInfo(db.Model):
    """Device information model"""
    id = db.Column(db.Integer, primary_key=True)
    device_id = db.Column(db.String(50), unique=True, nullable=False)
    name = db.Column(db.String(100), nullable=False)
    location = db.Column(db.String(200))
    ip_address = db.Column(db.String(15))
    last_seen = db.Column(db.DateTime)
    status = db.Column(db.String(20), default='online')
    config = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

# Create database tables
with app.app_context():
    db.create_all()

# MQTT connection event
@mqtt.on_connect()
def handle_connect(client, userdata, flags, rc):
    """Subscribe to topics after MQTT connection success"""
    logger.info(f"MQTT connection successful, return code: {rc}")
    # Subscribe to device data topics
    mqtt.subscribe('esp32/+/data/json')
    mqtt.subscribe('esp32/+/alert/#')
    mqtt.subscribe('esp32/+/status/#')
    logger.info("MQTT topics subscribed")

# MQTT message processing
@mqtt.on_message()
def handle_mqtt_message(client, userdata, msg):
    """Handle received MQTT messages"""
    try:
        topic = msg.topic.decode('utf-8')
        payload = msg.payload.decode('utf-8')
        
        logger.info(f"MQTT message received - Topic: {topic}, Payload: {payload}")
        
        if '/data/json' in topic:
            # Process sensor data
            data = json.loads(payload)
            process_sensor_data(data)
            
        elif '/alert/' in topic:
            # Process alert information
            alert_data = json.loads(payload)
            process_alert_data(alert_data)
            
    except Exception as e:
        logger.error(f"Error processing MQTT message: {e}")

def process_sensor_data(data):
    """Process sensor data"""
    try:
        # Save to database
        sensor_data = SensorData(
            device_id=data.get('device_id', 'unknown'),
            flame_value=data.get('flame', 0),
            smoke_value=data.get('smoke', 0),
            temperature=data.get('temperature'),
            humidity=data.get('humidity'),
            alert_status=data.get('alert', False)
        )
        db.session.add(sensor_data)
        db.session.commit()
        
        # Update device status
        device = DeviceInfo.query.filter_by(device_id=data.get('device_id')).first()
        if device:
            device.last_seen = datetime.utcnow()
            device.status = 'online'
        else:
            # Create new device record
            device = DeviceInfo(
                device_id=data.get('device_id'),
                name=f"ESP32-{data.get('device_id', 'unknown')}",
                location='Dormitory',
                last_seen=datetime.utcnow(),
                status='online'
            )
            db.session.add(device)
        db.session.commit()
        
        # Real-time push to frontend via WebSocket
        socketio.emit('sensor_data', data)
        logger.info(f"Sensor data saved and pushed: {data.get('device_id')}")
        
    except Exception as e:
        logger.error(f"Error processing sensor data: {e}")
        db.session.rollback()

def process_alert_data(alert_data):
    """Process alert data"""
    try:
        # Save alert record
        alert = AlertHistory(
            device_id=alert_data.get('device_id'),
            alert_type=alert_data.get('alert_type', 'unknown'),
            severity=alert_data.get('severity', 'medium'),
            flame_value=alert_data.get('sensor_values', {}).get('flame'),
            smoke_value=alert_data.get('sensor_values', {}).get('smoke'),
            temperature=alert_data.get('sensor_values', {}).get('temperature'),
            humidity=alert_data.get('sensor_values', {}).get('humidity'),
            location=alert_data.get('location', 'Unknown location')
        )
        db.session.add(alert)
        db.session.commit()
        
        # Push alert information to frontend
        socketio.emit('alert_data', alert_data)
        logger.warning(f"Alert record created: {alert_data.get('device_id')} - {alert_data.get('alert_type')}")
        
    except Exception as e:
        logger.error(f"Error processing alert data: {e}")
        db.session.rollback()

# Flask routes
@app.route('/')
def index():
    """Homepage - Real-time monitoring dashboard"""
    return render_template('index.html')

@app.route('/api/data/recent')
def get_recent_data():
    """Get recent sensor data"""
    try:
        limit = int(request.args.get('limit', 20))
        device_id = request.args.get('device_id')
        
        query = SensorData.query.order_by(SensorData.timestamp.desc())
        if device_id:
            query = query.filter_by(device_id=device_id)
            
        data = query.limit(limit).all()
        
        result = []
        for item in data:
            result.append({
                'id': item.id,
                'device_id': item.device_id,
                'flame': item.flame_value,
                'smoke': item.smoke_value,
                'temperature': item.temperature,
                'humidity': item.humidity,
                'alert': item.alert_status,
                'timestamp': item.timestamp.isoformat()
            })
        
        return jsonify(result)
    except Exception as e:
        logger.error(f"Error getting recent data: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/data/range')
def get_data_range():
    """Get data within time range"""
    try:
        start_time = request.args.get('start')
        end_time = request.args.get('end')
        device_id = request.args.get('device_id')
        
        query = SensorData.query
        if start_time:
            start = datetime.fromisoformat(start_time.replace('Z', '+00:00'))
            query = query.filter(SensorData.timestamp >= start)
        if end_time:
            end = datetime.fromisoformat(end_time.replace('Z', '+00:00'))
            query = query.filter(SensorData.timestamp <= end)
        if device_id:
            query = query.filter_by(device_id=device_id)
            
        data = query.order_by(SensorData.timestamp.desc()).all()
        
        result = []
        for item in data:
            result.append({
                'id': item.id,
                'device_id': item.device_id,
                'flame': item.flame_value,
                'smoke': item.smoke_value,
                'temperature': item.temperature,
                'humidity': item.humidity,
                'alert': item.alert_status,
                'timestamp': item.timestamp.isoformat()
            })
        
        return jsonify(result)
    except Exception as e:
        logger.error(f"Error getting range data: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/alerts')
def get_alerts():
    """Get alert history"""
    try:
        alerts = AlertHistory.query.order_by(AlertHistory.timestamp.desc()).limit(50).all()
        
        result = []
        for alert in alerts:
            result.append({
                'id': alert.id,
                'device_id': alert.device_id,
                'alert_type': alert.alert_type,
                'severity': alert.severity,
                'flame_value': alert.flame_value,
                'smoke_value': alert.smoke_value,
                'temperature': alert.temperature,
                'humidity': alert.humidity,
                'location': alert.location,
                'timestamp': alert.timestamp.isoformat(),
                'resolved': alert.resolved,
                'resolved_time': alert.resolved_time.isoformat() if alert.resolved_time else None
            })
        
        return jsonify(result)
    except Exception as e:
        logger.error(f"Error getting alert history: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/devices')
def get_devices():
    """Get device list"""
    try:
        devices = DeviceInfo.query.all()
        
        result = []
        for device in devices:
            result.append({
                'id': device.id,
                'device_id': device.device_id,
                'name': device.name,
                'location': device.location,
                'ip_address': device.ip_address,
                'last_seen': device.last_seen.isoformat() if device.last_seen else None,
                'status': device.status,
                'created_at': device.created_at.isoformat()
            })
        
        return jsonify(result)
    except Exception as e:
        logger.error(f"Error getting device list: {e}")
        return jsonify({'error': str(e)}), 500

@app.route('/api/data', methods=['POST'])
def receive_data():
    """Receive sensor data via HTTP POST (backup method)"""
    try:
        data = request.get_json()
        process_sensor_data(data)
        return jsonify({'status': 'success', 'message': 'Data received'})
    except Exception as e:
        logger.error(f"Error receiving HTTP data: {e}")
        return jsonify({'error': str(e)}), 500

# WebSocket events
@socketio.on('connect')
def handle_connect():
    """WebSocket connection event"""
    logger.info('Client connected')
    socketio.emit('connection_status', {'status': 'connected'})

@socketio.on('disconnect')
def handle_disconnect():
    """WebSocket disconnection event"""
    logger.info('Client disconnected')

# Scheduled cleanup of expired data
def cleanup_old_data():
    """Clean up data older than 30 days"""
    while True:
        try:
            with app.app_context():
                cutoff_time = datetime.utcnow() - timedelta(days=30)
                old_data = SensorData.query.filter(SensorData.timestamp < cutoff_time).delete()
                db.session.commit()
                logger.info(f"Cleaned up {old_data} expired records")
        except Exception as e:
            logger.error(f"Error cleaning up data: {e}")
        time.sleep(86400)  # Execute once daily

# Start cleanup thread
cleanup_thread = threading.Thread(target=cleanup_old_data, daemon=True)
cleanup_thread.start()

if __name__ == '__main__':
    logger.info("Starting ESP32 Dormitory Fire Alarm System Web Server...")
    logger.info("Access URL: http://localhost:5000")
    socketio.run(app, host='0.0.0.0', port=5000, debug=True, allow_unsafe_werkzeug=True)